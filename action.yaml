name: queue-behind-previous-run

description: >-
  Will queue this workflow behind a the previously ran one if it is running, and wait until
  the given job to watch is available for another job to progress to it without cancelling
  any pending workflow runs.

inputs:
  JOB_NAME:
    description: the job in the workflow to watch to determine if still in queue
    type: string
    required: true
  SECONDS_BETWEEN_WATCHES:
    description: how long to sleep before observing the state of the run that's being watched
    type: string
    required: true
    default: 15

runs:
  using: composite
  steps:
    - id: get-prev-run
      uses: ./.github/actions/get-previous-run
      with:
        RUN_NUMBER: ${{ github.run_number }} # always >= 1
        RUN_WORKFLOW_NAME: ${{ github.workflow }}

    - id: watch-loop
      env:
        RUN_TO_WATCH: ${{ steps.get-prev-run.outputs.id }}
        JOB_TO_WATCH: ${{ inputs.JOB_NAME }}
        SLEEP_AMOUNT: ${{ inputs.SECONDS_BETWEEN_WATCHES }}
        GITHUB_TOKEN: ${{ github.token }}
      shell: bash
      run: |
        view_run_res=$(mktemp)
        echo "::info::beginning to watch run (ID: $RUN_TO_WATCH)"
        # TODO implement a backoff; if set too low, can blow up your token's rate limits
        sleep_amount="$SLEEP_AMOUNT"
        while : ; do
          gh run view -R ${{ github.repository }} \
              "$RUN_TO_WATCH" --json conclusion,jobs,number > $view_run_res
          # <debug>
          echo "::group::[debug] JSON output from \`gh run view ...\` at $(date --iso-8601=seconds)"
          jq . $view_run_res
          echo '::endgroup::'
          # </debug>
          watched_run=$(jq --raw-output '.conclusion' $view_run_res)
          if [[ $watched_run == "" ]]; then
            # first, try to see if the job being queued for has started, and what its current state is...
            jobs=$(jq --compact-output --arg jn "$JOB_TO_WATCH" '.jobs | map(select(.name |
                . == $jn or startswith($jn + " ")))' $view_run_res)
            # jobs that are made up of multiple subjobs will be named in the format <job-name> / <subjob-name>
            if [[ $(jq 'length' <<< $jobs) > 0 ]]; then
              # ... the job has started, so first see if it has finished unsuccessfully...
              failed_or_cancelled_jobs=$(jq 'map(select(
                  .conclusion == "cancelled" or .conclusion == "failure")) | length' <<< $jobs)
              if [[ $failed_or_cancelled_jobs > 0 ]]; then
                echo '::warning::job being watched (or its subjobs) has either failed or been cancelled;' \
                    ' cancelling this job...'
                echo 'cancel-run=true' | tee -a "$GITHUB_OUTPUT"
                break # exit loop
              fi
              # ... and then see if it's in a state that will allow this workflow to progress without
              # dequeuing a different pending workflow
              jobs_to_wait_for=$(jq 'map(select(
                  .conclusion != "" or .status == "waiting" | not)) | length' <<< $jobs)
              if [[ $jobs_to_wait_for > 0 ]]; then
                echo "::info::job being wtched has $jobs_to_wait_for (sub)jobs before this run can progress;" \
                    " waiting for ${sleep_amount}s..."
                sleep $sleep_amount
              else
                echo '::info::job being watched is in a state where this workflow run can progress'
                break # exit loop
              fi
            else
              echo "::info::job to watch has not yet started; waiting for ${sleep_amount}s..."
              sleep $sleep_amount
            fi
          else
            if [[ $watched_run == 'cancelled' ]] || [[ $watched_run == 'failure' ]]; then
              echo '::warning::workflow containing job to watch has concluded due to either error ' \
                  'or being cancelled; cancelling this job...'
              echo 'cancel-run=true' | tee -a "$GITHUB_OUTPUT"
            else
              echo '::info::workflow containing job to watch has concluded'
            fi
            break # exit loop
          fi
        done

# the following assumptions were made regarding interpreting values for "status":
#
# only when .conclusion != "" (concluded):
# - completed
# - cancelled
# - failure
# - neutral
# - skipped
# - (maybe?) stale
# - success
# - (maybe?) timed_out
#
# only when .conclusion == "" (not concluded):
# - in_progress (happens when a workflow job (steps, too?) is executing)
# - queued (happens when workflow (steps, too?) has been notified to start, but has not yet started
# - waiting (happens when waiting for protected environment requirements to be satisfied)
# - pending (happens when waiting for concurrency group key)
#
# note exactly sure...:
# - action_required, only when concluded? does this happen when a job or step cannot call reusable workflow or action?
# - requested, only when has not concluded? cron related? (similar case to "queued" status?)

    - name: Cancel current workflow
      if: steps.watch-loop.outputs.cancel-run == 'true'
      env:
        SLEEP_AMOUNT: ${{ inputs.SECONDS_BETWEEN_WATCHES }}
        GITHUB_TOKEN: ${{ github.token }}
      shell: bash
      run: |
        gh run cancel -R ${{ github.repository }} ${{ github.run_id }}
        sleep "$SLEEP_AMOUNT"
