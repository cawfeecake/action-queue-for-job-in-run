name: concurrency-queue

description: Holds the thread with sleeps until the watched job on the given workflow run has either completed or is no longer waiting for the concurrency lock

inputs:
  RUN_ID:
    description: id for the run to be watching
    type: string
    required: true
  JOB_NAME:
    description: the job in the workflow to watch
    type: string
    required: true

runs:
  using: composite
  steps:
    - id: loop
      env:
        GITHUB_TOKEN: ${{ github.token }}
      shell: bash
      run: |
        view_run_res=$(mktemp)
        echo '::group::watching run (ID: ${{ inputs.RUN_ID }})'
        while : ; do
          gh run view -R ${{ github.repository }} \
              ${{ inputs.RUN_ID }} --json conclusion,jobs,number > $view_run_res
          # <debug>
          echo '::info::return from `gh run view ...`'
          jq . $view_run_res
          # </debug>
          if [[ $(jq --raw-output '.conclusion' $view_run_res) == "" ]]; then
            # first, check if job has started yet...
            if $(jq --raw-output '.jobs[].name' $view_run_res | grep -q '^${{ inputs.JOB_NAME }} /'); then
              # and if it has, see if all of its parts have completed (to point of being able to pop from head of queue)
              jobs_being_waited_on=$(jq --compact-output \
                  '[ .jobs[] | select(.name | startswith("${{ inputs.JOB_NAME }} ")) | select(.conclusion != "" or .status == "waiting" | not) ] | length' $view_run_res)
              if [[ $jobs_being_waited_on > 0 ]]; then
                echo '::info::job is still executing, and no space in concurrency queue; waiting...'
                sleep 30
              else
                echo '::info::job has concluded, or its concurrency key is available for queueing'
                break
              fi
            else
              echo '::info::job is not yet seen in watched run; waiting...'
              sleep 30
            fi
          else
            echo '::info::workflow has concluded'
            break
          fi
        done
        echo '::endgroup::'

# note: assumptions on status based on the following breakdown
#
# only when concluded:
# - completed
# - cancelled
# - failure
# - neutral
# - skipped
# - stale (?)
# - success
# - timed_out (?)
#
# only when has not concluded:
# - in_progress (happens when a workflow job (steps, too?) is executing)
# - queued (happens when workflow (steps, too?) has been notified to start, but has not yet started
# - waiting (happens when waiting for protected environment requirements to be satisfied)
# - pending (happens when waiting for concurrency group key)
#
# (?) unknown:
# - action_required, only when concluded? does this happen when a job or step cannot call reusable workflow or action?
# - requested, only when has not concluded? cron related? (similar case to "queued" status?)
